## Automatic Modification of Classes

### Overview

The ETAI library provides several means for modifying classes and derived classes automatically, especially for generating boilerplate code.

The modification is usually driven by **rules** which support the following use cases:

- generation of **factory methods and factory classes**,
- generation of **getter, setter, adder and remover methods** for regular fields, collections and maps including features like *null*-checks, calling methods on changes or maintaining bidirectional connections
- **adaption of return types and parameter types** of methods/constructors based on the current class in the class hierarchy and
- **adaption of the methods/constructors implementations** based on the current class in the class hierarchy.

In order to enable the modification of classes and derived classes based on rules, it is necessary to attach ***@ApplyRules*** to the class which specifies such rules as well as to any derived class.

The **generation of default implementations of methods found in interfaces** is also possible with the ETAI library and described in the following. However, this generation is not based on rules and does not require *@ApplyRules* therefore.

##### Important

> Please note, that once *@ApplyRules* is attached to a class all derived classes **must** also use this annotation. This will be checked via assertions during runtime.

### Generate Accessors and Mutators

Coding getter and setter methods is common in object-oriented programming and especially Java. For example, there is usually a method *getAge* for accessing field *age* or a method *setName* for changing field *name*. This is a requirement for keeping the principle of encapsulation.

However, such methods are a prototype of boilerplate code and as a consequence many code generation technologies support the automatic generation. Even Xtend provides some exemplary active annotations, which perform this job.

The ETAI library also provides some active annotations. In contrast to the basic implementation, which is shipping with Xtend, there are more features and the annotations will fit to other mechanisms of the ETAI library. 

In order to enable the **generation of getter and setter**, specific rules (active annotations) must be attached to the fields of a class. Available rules will be explained in the following sub sections.

Besides getters and setters the ETAI library also supports a special treatment for fields, which have the type *java.util.Collection* (or any derived type like *java.util.List* and *java.util.Set*) and *java.util.Map* (or any derived type). The usage of such types allows the **generation of so-called adder and remover** methods, which can be used to add/put or remove values to/from the collections/maps.

In the following, getter methods will also be referenced as **accessors**. Setter, adder and remover methods will also be called **mutators**. 

Active annotations for generating accessors and mutators can only be applied to **non-*public* fields**. However, the methodology supports *static* fields. In this case, the generated methods will also be *static*. However, even if the field is declared *final*, the generated method will be non-*final*.

The generated methods will perform their basic job, of course. In addition, they are able to

- perform ***null* checks**, e.g. fields can require that will never get the value *null*,
- **call other methods on changes**, e.g. in order to trigger additional effects,
- synchronize with an "opposite" field in case of **bidirectional connections**.

All topics will be covered by later sub sections.

##### Hint

> Some annotations like *@ExclusiveMethod* (or other trait methods, see [Traits](#traits)), *@TypeAdaptionRule* (see [Reimplement Constructors and Methods with Adapted Parameter and Return Types](#reimplement-constructors-and-methods-with-adapted-parameter-and-return-types)) or *@NoInterfaceExtract* (see [Adapt Interface Extraction](#adapt-interface-extraction)) are related to methods and must annotate methods therefore. However, they can also annotate fields, if these fields apply annotations for generating accessors or mutators. In such a case, the annotations behave as if they would be annotated to the generated methods.
>
> For example, if *@ExclusiveMethod* and *@GetterRule* are used together for a field in a trait class, a getter method will be generated as exclusive trait method of that trait class, i.e. each class extended by this trait class will receive this getter method.

#### Generate Getter and Setter Methods

The generation of getter and setter methods can be triggered by the annotation of ***@GetterRule*** and ***@SetterRule***. Both annotations can be used independently, i.e., if only *@GetterRule* is used, only a getter method will be generated.

In contrast to the common pattern, the generated setter method will return a *boolean* value. A result of *true* means that the actual value of the field has been changed. On contrary, *false* means that the value has not been changed. This can happen, if the new value (resp. reference) would have been the same as the old one. However, there are also other possibilities that the value is not changed in context of [change methods](#change-methods).

The following example shows class *Person* which specifies the field *name* and uses *@GetterRule* and *@SetterRule* for it. Therefore, the methods *getName* and *setName* are generated. They allow for accessing the field's value and modifying the field's value.

The example also shows the usage of parameter ***visibility***. It is available for all rules for generating accessors and mutators, i.e. not only getter and setter methods, but also adder and remover methods. The parameter can be set to *PUBLIC* and *PROTECTED*. In the example, *@SetterRule* requires the generated setter to be *protected*. By default, all generated accessors and mutators are generated *public*.  

##### Input (Code)

[!include_code code_modification_getter_setter.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_GetterSetter_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_GetterSetter_Out.png)

##### Hint

> The names for generating getter and setter methods are based on the name of the field and cannot be adjusted. Of course, the naming rules consider the most common pattern, e.g. like specified for JavaBeans (see [JavaBeans](http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/), chapter "Design Patterns for Properties"). The according naming conventions are also supported by [Xtend](https://www.eclipse.org/xtend/documentation/) (see "Property Access").
>
> The example above shows that the field *name* leads to the getter *getName* and setter *setName*. However, in case of a *boolean* field *X* (not *Boolean*) the generated getter would be called *isX*.

#### Generate Adder and Remover Methods

If a field has type *java.util.Collection* (or any derived type like *java.util.List* and *java.util.Set*) or *java.util.Map* (or any derived type), it is possible to apply the annotations ***@AdderRule*** and ***@RemoverRule***. They trigger the generation of methods for adding resp. removing elements to/from the *Collection*/*Map*.

Both annotations support the *boolean* parameters ***single*** and ***multiple***. They control which types of methods will be generated: if *single* is *true*, methods for adding/removing single elements are generated, if *multiple* is *true*, methods for adding/removing multiple elements are generated. At least one of both options must be set to *true*.   

The following tables show which methods are generated for a field named *X* based on the type (with element type *E* resp. key/value types *K*/*V*) and the applied annotation. 

| Method (*@AdderRule*)        | *single* /<br>*multiple* | Type  | Description                         |
| -------------------------- |:------:|:--------:|------------------------------------:|
| ***boolean addToX(E element)*** | *single* | *Collection* | *element* will be added to collection *X* (if the type is *List*, it will be added to the end of the list) |
| ***boolean addToX(int index, E element)*** | *single* | *List* | *element* will be added to list *X* at the specified *index* |
| ***V putToX(K key, V value)*** | *single* | *Map* | *value* for *key* will be put to to map *X*, the old value (resp. *null* if not available) will be replaced and returned by the method |
| ***boolean addAllToX(Collection&lt;E&gt; c)*** | *multiple* | *Collection* | the whole collection *c* will be added to collection *X* (if the type is *List*, it will be added to the end of the list) |
| ***boolean addAllToX(int index, Collection&lt;E&gt; c)*** | *multiple* | *List* | the whole collection *c* will be added to list *X* at the specified *index* |
| ***void putAllToX(Map&lt;? extends K,? extends V&gt; m)*** | *multiple* | *Map* | all entries of map *m* will be put to map<nobr>&nbsp;<nobr>*X* |

| Method (*@RemoverRule*)      | *single* /<br>*multiple* | Type  | Description                         |
| -------------------------- |:------:|:--------:|------------------------------------:|
| ***boolean removeFromX(int index)*** | *single* | *List* | the element with the specified *index* will be removed from list *X* |
| ***boolean removeFromX(E element)*** | *single* | *Collection* | *element* will be removed from collection *X* (if the element is contained multiple times, the first occurrence will be replaced) |
| ***V removeFromX(K key)*** | *single* | *Map* | the entry for the given *key* will be removed from map *X* (returns the removed value or *null* if it did not exist) |
| ***boolean removeAllFromX(Collection&lt;E&gt; c)*** | *multiple* | *Collection* | all elements in collection *c* will be removed from collection *X* (if an element is contained multiple times, all occurrences will be removed) |
| ***boolean/void clearX()*** | *multiple* | *Collection*<nobr>&nbsp;<nobr>/<br>*Map* | the whole collection / map *X* will be emptied |

All methods which return a *boolean* value will report, if there has been any change in the *Collection* (this is not available for *Map*). This can happen, for example, if the new element has already been contained in a *Set*. However, there are also other possibilities in context of [change methods](#change-methods).

An example will be shown in the following sections.

##### Important

> The generated methods do not check or take care that the used *Collection* or *Map* exists or is constructed. It should be ensured that the field is initialized directly or inside the constructor and never gets *null*.

##### Limitation

> It is not recommended to use wildcards and upper bounds for the field's collection type, e.g. *java.util.List<? extends Object>*. Basically, it would not be possible to generate concrete methods in order to add or remove elements then. For example, it is not sure that the given concrete type (*Object* in the example) can be put into the collection. Even using method *add* for the connection itself is not possible. However, the ETAI will still generate methods with the given upper bound. The correct usage must be ensured by the programmer therefore.

#### Getter Methods for Collections and Maps: *collectionPolicy*

Adder and remover methods as shown in the previous section can be used in order to modify collections/maps. However, there usually is the need to access elements of these collections/maps as well.

This can be achieved by applying a *@GetterRule* to the collection/map. Once it is returned by the getter, it can be used to access its elements. However, this might bypass the idea of encapsulation, because the returned reference can also be used to modify the collection/map without using the generated adder and remover methods.

Therefore, *@GetterRule* supports a parameter called ***collectionPolicy***. Setting this parameter can influence how the collection/map is returned, and it can be protected this way. The following values are supported and have the described effect:

- ***UNMODIFIABLE*** (default): the collection/map is returned inside of a read-only wrapper.
- ***UNMODIFIABLE_COPY***: a copy of the collection/map is returned inside of a read-only wrapper.
- ***DIRECT***: the collection/map is returned directly, i.e., there is no protection.

Returning a collection/map inside of a read-only wrapper means that an unmodifiable collection/map is constructed via *java.util.Collections*. Depending on the type of the collection/map the method *unmodifiableList*, *unmodifiableSet*, *unmodifiableSortedSet*, *unmodifiableCollection*, *unmodifiableMap* or *unmodifiableSortedMap* is used. 

The following example shows the usage of *@GetterRule*, *@AdderRule* and *@RemoverRule* together with a list called *paragraphs*. Both *@AdderRule* and *@RemoverRule* have the parameter *single* set to *true*, which is the default. Parameter *multiple*, however, is set to *true* only for *@RemoverRule*. These settings together with type *java.util.List* result in the generated methods shown in the output diagram. 

The parameter *collectionPolicy* is set to *UNMODIFIABLE_COPY* for the generation of the getter. This means that the getter shall return a read-only copy of the list. This way, there is no problem with concurrent modifications when iterating through the elements of *paragraphs* (or rather a snapshot of it) and changing it at the same time. Therefore, the exemplary code shown in *duplicateParagraph* works without exception.

##### Input (Code)

[!include_code code_modification_getter_adder_remover.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_GetterAdderRemover_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_GetterAdderRemover_Out.png)

#### *null* Checks

In context of accessors (*@GetterRule*) and mutators (*@SetterRule* and *@AdderRule*) it is possible to **protect against setting fields to *null*, adding *null* to collections/maps or retrieving a *null* value from the field or even the collection/map**. This protection can be activated by annotating the according field with ***@NotNullRule*** in addition.

The annotation supports three *boolean* parameters:

- ***notNullSelf*** (default *true*): the value of the field itself must not be set to *null* (via setter) and when retrieving the value (via getter), it must not be *null*.
- ***notNullKeyOrElement*** (default *false*): it is not allowed to add a *null* element to a collection resp. to add a *null* key to a map (via adder).
- ***notNullValue*** (default *false*): it is not allowed to add a *null* value to a map (via adder).

If the specified *null* rule is violated, which can detected during the according method call (getter, setter or adder method), an *AssertionError* will be thrown. This requires assertions to be activated (see [Enabling and Disabling Assertions](https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html#enable-disable)).

The code example below shows the usage of *NotNullRule* twice. Firstly, it is not possible to set the name of a *Person* object to *null*. In addition, if a name with value *null* is be retrieved via getter (actually the field has this value directly after the object has been constructed), an error will be thrown.

Secondly, the set *addresses* cannot retrieved, if it is *null* or contains a *null* element. When adding new elements to the set, it is checked that they are not *null* as well.

##### Input (Code)

[!include_code code_modification_getter_setter_adder_notnull.txt]

##### Hint

It is also ensured that only non-*null* values/keys can be retrieved from collections/maps using the generated getter method. This can only be achieved by checking each element of the collection/map before returning the reference. As this is a very time consuming operation this feature should be considered as convenient helper for testing purposes and only be used for small collections/maps.  

##### Important

There is no protection, if the field/collection/map is modified or accessed directly without getter, setter or adder.

#### Change Methods

Before/after the value of a field or the content of a collection is changed, it is sometimes necessary to **trigger some additional checks or actions**. In this case, it is possible to write a non-generated mutator method accordingly. However, triggering additional checks or actions is also possible, if generating mutators via *@SetterRule*, *@AdderRule* or *@RemoverRule*.

All rules for generating mutator methods support some additional parameters of type *String*, e.g. parameter *afterChange* is supported by *@SetterRule*. Their purpose is to hold the name of a method, which must be available in context of the generated mutator method (*static* or non-*static*). The method must also comply with one of several allowed signatures. If such a parameter is set, the referenced method is called inside the generated mutator method. It is even possible to block a change.

The specified method name can use the *%* symbol. This symbol will be replaced automatically by the field's name applying also the camel case schema.

The following table shows an overview of available parameters together with the point in time in which the referenced method is called:

| Rule        | Parameter | Trigger                             |
| ----------- |-----------|------------------------------------:|
| *@SetterRule* | *beforeChange* | before the field's value is going to be changed |
| *@SetterRule* | *afterChange* | after the field's value has been changed |
| *@AdderRule* | *beforeAdd* | before one or more elements are going to be added to the collection |
| *@AdderRule* | *beforeElementAdd* | before an element is going to be added to the collection |
| *@AdderRule* | *afterElementAdd* | after an element has been added to the collection |
| *@AdderRule* | *afterAdd* | after one or more elements have been added to the collection |
| *@RemoverRule* | *beforeRemove* | before one or more elements is going to be removed from the collection |
| *@RemoverRule* | *beforeElementRemove* | before an element is going to be removed from the collection |
| *@RemoverRule* | *afterElementRemove* | after an element has been removed from the collection |
| *@RemoverRule* | *afterRemove* | after one or more elements have been removed from the collection |

Please note, that multiple methods can be called during one call of a generated mutator. For example, if a field's value is going to be set to a new value, i.e. the value differs from the old one, the method referenced by *beforeChange* will be called before the actual change, and the *boolean* result of this call can even block the change. After the change has been performed the method referenced by *afterChange* will be called.

If adding multiple elements to a collection, the method referenced by *beforeElementAdd* is called **for each element**. Afterwards, the method referenced by *beforeAdd* will be called. Thereby, adding elements can be blocked individually or entirely. For each element, which has actually been added, the method referenced by *afterElementAdd* will be called then. Finally, *afterAdd* will be called, if there are elements, which have been added. For removing elements the same schema is applied.

All referenced methods must have one of multiple possible signatures. Depending on the signature, information about the change will be available inside the method. The following table shows all supported signatures. The meaning of the individual signature elements will be explained below the table.

| Parameter     | Signature of the called method                   |
|---------------|-------------------------------------------------:|
| *beforeChange*&nbsp;/<br>*afterChange* | *void X()*
| *beforeChange*&nbsp;/<br>*afterChange* | *void X(T newValue)*
| *beforeChange*&nbsp;/<br>*afterChange* | *void X(T oldValue, T newValue)*
| *beforeChange*&nbsp;/<br>*afterChange* | *void X(String fieldName, T oldValue, T newValue)*
| *beforeAdd*&nbsp;/<br>*afterAdd*&nbsp;/<br>*beforeRemove*&nbsp;/<br>*afterRemove* | *void X()*
| *beforeAdd*&nbsp;/<br>*afterAdd*&nbsp;/<br>*beforeRemove*&nbsp;/<br>*afterRemove* | *void X(List&lt;T&gt; elements)*
| *beforeAdd*&nbsp;/<br>*afterAdd*&nbsp;/<br>*beforeRemove*&nbsp;/<br>*afterRemove* | *void X(String fieldName, List&lt;T&gt; elements)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeAdd*&nbsp;/<br>&nbsp;&nbsp;*afterAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeRemove*&nbsp;/<br>&nbsp;&nbsp;*afterRemove* | *void X(List&lt;Integer&gt; indices, List&lt;T&gt; elements)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeAdd*&nbsp;/<br>&nbsp;&nbsp;*afterAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeRemove*&nbsp;/<br>&nbsp;&nbsp;*afterRemove* | *void X(String fieldName, List&lt;Integer&gt; indices, List&lt;T&gt; elements)*
| not supported for *List*:<br>&nbsp;&nbsp;*beforeAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeRemove* | *void X(List&lt;T&gt; oldElements, List&lt;T&gt; elements)*
| not supported for *List*:<br>&nbsp;&nbsp;*beforeAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, List&lt;T&gt; elements)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeRemove* | *void X(List&lt;T&gt; oldElements, List&lt;Integer&gt; indices, List&lt;T&gt; elements)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, List&lt;Integer&gt; indices, List&lt;T&gt; elements)*
| not supported for *List*:<br>&nbsp;&nbsp;*afterAdd*&nbsp;/<br>&nbsp;&nbsp;*afterRemove* | *void X(List&lt;T&gt; oldElements, List&lt;T&gt; newElements, List&lt;T&gt; elements)*
| not supported for *List*:<br>&nbsp;&nbsp;*afterAdd*&nbsp;/<br>&nbsp;&nbsp;*afterRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, List&lt;T&gt; newElements, List&lt;T&gt; elements)*
| supported for *List* only:<br>&nbsp;&nbsp;*afterAdd*&nbsp;/<br>&nbsp;&nbsp;*afterRemove* | *void X(List&lt;T&gt; oldElements, List&lt;T&gt; newElements, List&lt;Integer&gt; indices, List&lt;T&gt; elements)*
| supported for *List* only:<br>&nbsp;&nbsp;*afterAdd*&nbsp;/<br>&nbsp;&nbsp;*afterRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, List&lt;T&gt; newElements, List&lt;Integer&gt; indices, List&lt;T&gt; elements)*
| *beforeElementAdd*&nbsp;/<br>*afterElementAdd*&nbsp;/<br>*beforeElementRemove*&nbsp;/<br>*afterElementRemove* | *void X(T element)*
| *beforeElementAdd*&nbsp;/<br>*afterElementAdd*&nbsp;/<br>*beforeElementRemove*&nbsp;/<br>*afterElementRemove* | *void X(String fieldName, T element)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeElementAdd*&nbsp;/<br>&nbsp;&nbsp;*afterElementAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeElementRemove*&nbsp;/<br>&nbsp;&nbsp;*afterElementRemove* | *void X(int index, T element)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeElementAdd*&nbsp;/<br>&nbsp;&nbsp;*afterElementAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeElementRemove*&nbsp;/<br>&nbsp;&nbsp;*afterElementRemove* | *void X(String fieldName, int index, T element)*
| not supported for *List*:<br>&nbsp;&nbsp;*beforeElementAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeElementRemove* | *void X(List&lt;T&gt; oldElements, T element)*
| not supported for *List*:<br>&nbsp;&nbsp;*beforeElementAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeElementRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, T element)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeElementAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeElementRemove* | *void X(List&lt;T&gt; oldElements, int index, T element)*
| supported for *List* only:<br>&nbsp;&nbsp;*beforeElementAdd*&nbsp;/<br>&nbsp;&nbsp;*beforeElementRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, int index, T element)*
| not supported for *List*:<br>&nbsp;&nbsp;*afterElementAdd*&nbsp;/<br>&nbsp;&nbsp;*afterElementRemove* | *void X(List&lt;T&gt; oldElements, List&lt;T&gt; newElements, T element)*
| not supported for *List*:<br>&nbsp;&nbsp;*afterElementAdd*&nbsp;/<br>&nbsp;&nbsp;*afterElementRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, List&lt;T&gt; newElements, T element)*
| supported for *List* only:<br>&nbsp;&nbsp;*afterElementAdd*&nbsp;/<br>&nbsp;&nbsp;*afterElementRemove* | *void X(List&lt;T&gt; oldElements, List&lt;T&gt; newElements, int index, T element)*
| supported for *List* only:<br>&nbsp;&nbsp;*afterElementAdd*&nbsp;/<br>&nbsp;&nbsp;*afterElementRemove* | *void X(String fieldName, List&lt;T&gt; oldElements, List&lt;T&gt; newElements, int index, T element)*

The following elements are used in the table above:

- *X*: the name of the called method
- *T*: the type of the annotated field resp. the type of the collection's element
- *fieldName*: the name of the field/collection which shall be changed
- *oldValue*: the old value of the field
- *newValue*: the new value of the field (which has or has not already been set)
- *element* / *elements*: the element(s) which shall be/have been added/removed to/from the collection (read-only)
- *oldElements*: the element(s) which have been in the collection before the change (read-only)
- *newElements*: the element(s) which will be in the collection after the change (read-only)
- *index* / *indices*: the index/indices of the elements(s) which shall be added/removed to/from the collection

All methods which are triggered before a change also support return type *boolean* in addition to *void*. If *boolean* is used, the return value of the method will **control, if the change is allowed and shall be performed**. If *false* is returned, the change will be aborted. In case of methods called for individual elements of a bigger change (e.g. *beforeElementAdd*) only adding/removing this particular element will be skipped.

Please note, that not all kind of actions should be performed within change methods. For example, throwing exceptions might be problematic (see [Bidirectional Connections](#bidirectional-connections)). Also the currently changed value resp. the currently altered collection should not be changed again within the change method. This might lead to (endless) recursive calls. Therefore, there is even a protection against concurrent changes at least if mutator methods are called. For example, inside a change method for a field *A* triggered by setter *setA* another call of *setA* will not change *A* and return *false*.

The following code example shows how change methods can be used and also how a (logically) equivalent Java code would look like. It applies *beforeChange* and *afterChange* together with *@SetterRule* (field *percentage*) and *afterAdd* together with *@AdderRule* (field *log*).

In case of *percentage* the *beforeChange* method *percentageChange* checks, if the new value is between 0 and 100. If not, it will not be applied (but also no error is thrown). If the value is actually changed, method *percentageChanged* will be called. In the example, this method does not need any information and just wants to report a change, so no parameter is specified.

Field *log* is a *String* list. After new strings have been added, *afterAdd* method *addedToList* is called. It gets information about all added strings and their indices within *log*, and it reports these changes as well.

##### Input (Code)

[!include_code code_modification_change_method.txt]

##### Output (Code - Logical)

[!include_code code_modification_change_method_out_logical.txt]

##### Limitation

> It is not possible to use change methods for maps.

#### Bidirectional Connections

In object-oriented data models it is often required that two objects link to each other (bidirectional connection). In object-oriented programming this would mean that a reference is set from both sides, e.g. by calling a setter method for both objects. If it is known that a bidirectional connection must be established, however, it would be sufficient to call one setter, because **setting the bidirectional connection from the other side (opposing side) can be done automatically**.

The ETAI library supports the generation of mutator methods, which can handle bidirectional connections automatically, i.e., setting a reference on one side is sufficient. To enable this feature it is necessary to add rule ***@BidirectionalRule*** to a field, which references to another (opposing) object. As value of the rule a string must be provided. The string designated the field in the opposing object, which represents the opposing side of the bidirectional connection. 

If the mutator of a field annotated by *@BidirectionalRule* is called, also the opposing object will get according information about the connection. This information will be stored inside the field named in *@BidirectionalRule* by calling an appropriate mutator of the opposing object. This way, both objects contain a reference to each other and a bidirectional connection is established.

In object-oriented data modeling (bidirectional) associations with **0..1:1, 0..1:n and m:n multiplicities** can be modeled. These schemas can be reproduced via *@BidirectionalRule*. If both sides use a simple reference, the 0..1:1 schema will be applied and setter methods on both sides are expected (e.g. via *@SetterRule*). If one side uses a simple reference and the other side a set of references (*java.util.Set*), the 0..1:n schema will be applied. The side containing a set of references is required to have adder and remover methods for single references (e.g. via *@AdderRule*/*@RemoverRule* and *single* set to *true*), the other side is required to have a setter method again. Finally, if both sides have a set of references, the m:n schema will be applied and adder/remover methods are required on both sides.

An example for realizing a 0..1:n association is shown below. On one side, there is field *location* in class *City*, and on the other side, there is field *cities* in class *Country* and they refer to each other. If a *City* object sets a *Country* object as *location*, this *City* object will be added to the *cities* set within the *Country* object. The *City* object will also be removed from any *cities* set it has been before. The other way around, if a *Country* object adds a *City* object to *cities*, this *Country* object will be set as *location* for the *City* object. This behavior is also reflected in the exemplary output code shown below.

##### Input (Code)

[!include_code code_modification_bidirectional.txt]

##### Output (Code - Logical)

[!include_code code_modification_bidirectional_out_logical_1.txt]

[!include_code code_modification_bidirectional_out_logical_2.txt]

##### Hint

> It is not necessary that both sides declare a *@BidirectionalRule*. This way, it is possible to implement the mutator(s) on one side manually. Setting up the bidirectional connection from this side, however, should also be coded manually then.

##### Limitation

> If a new bidirectional connection shall be established, potential old connections must be cut. With the currently implemented logic this would mean that some fields must be set to *null* at least temporarily. Therefore, it is not possible to perfectly reproduce 1:1 or 1:n associations, e.g. by using *@NotNullRule* in addition (see [*null* Checks](#null-checks)). 
>
> In addition to this, if bidirectional connections are used, the usage of [change methods](#change-methods), which are called before a change, might be restricted. For example, during the call of such a change methods the current connection state might be inconsistent, because the internal algorithms are still processing a consistent connection state using mutator methods. Therefore, throwing exceptions there should be avoided.

#### Multi-Threading and Mutators

Calling generated mutators cannot be seen as atomic operation. Mutators can have complex operations behind, e.g. in order to create a consistent state of bidirectional connections (see [Bidirectional Connections](#bidirectional-connections)). Therefore, generated accessors and mutators should not be used in multi-threading scenarios except additional **synchronization mechanisms** are added. Such mechanisms can be added by applying annotation ***@SynchronizationRule***.

If this rule is applied, the generated accessor and mutator functionality will be embedded in a block with a fair reentrant read/write lock (*java.util.concurrent.locks.ReentrantReadWriteLock*). This means that multiple calls of one accessor from different thread can run in parallel, but one call of a mutator will block all accessor and mutator calls from other threads (not from this thread) until the change has been finalized.

*@SynchronizationRule* must specify the name of the lock via its *value*. The applied name is used to acquire a lock from a global namespace. This means that fields using *@SynchronizationRule* with the same name actually use the same lock. In general, the locking mechanism does not work object-centric but class-centric, so accessing the same field of two different objects in different threads can block each other.

If the example from the section for [bidirectional connections](#bidirectional-connections) is used in a multi-threading environment, it should apply *@SynchronizationRule* for *location* and *cities* with the same lock name. This is shown in the code below.

##### Input (Code)

[!include_code code_modification_synchronization.txt]

##### Hint

In particular, the usage of a shared lock name in *@SynchronizationRule* can be very important, if using *@BidirectionalRule* in a multi-threading environment. If changes are initiated from different threads, deadlocks can occur. This problem can be resolved by using the same lock (name) on both sides.

### Generate the Implementation of Constructors and Methods

It is possible to **generate method or constructor implementations in derived classes based on an adaption rule** specified in a parent class. This rule is annotated on an abstract or non-abstract method by using ***@ImplAdaptionRule***. By default, each derived class will implement this method then using this rule.

The adaption rule is given by a string assigned to the ***value*** of *@ImplAdaptionRule*. It must follow the schema described in [Adaption Rule Specification](#adaption-rule-specification). The string will be evaluated during code generation and the evaluation result will be the (Java) code of the generated method's body.

There is also another supported parameter: ***typeExistenceCheck***. With this parameter another adaption rule can be specified. It is also evaluated whenever an implementation shall be generated. However, before the latter actually happens, the result of the evaluation based on *typeExistenceCheck* will be checked. If it does not resolve to an existing (qualified) type, the implementation will not be generated.

A very simple use case is shown in the example below. The methods *getClassName* and *createSoundObject* shall be generated in derived classes of *Animal* based on the name of the derived class. For example, the method *getClassName* of *AnimalDog* will return the string *"virtual.AnimalDog"* while *getClassName* of *AnimalLion* will return *"virtual.AnimalLion"* without the usage of Java Reflection.

The method *createSoundObject* will create a corresponding *Sound* object, e.g. *SoundDog* for *AnimalDog* and *SoundLion* for *AnimalLion*. Within *AnimalZebra* this method is not generated, because the rule also specified an appropriate *typeExistenceCheck*, but the resulting type *virtual.SoundZebra* does not exist.
 
##### Input (Code)

[!include_code code_modification_implementation.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_Implementation_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_Implementation_Out.png)

### Reimplement Constructors and Methods with Adapted Parameter and Return Types

With type adaption rules it is possible to **adjust the return type of a method** within derived classes. This means that wrapper method with the adapted types are generated, i.e., they are simply calling the method of the super class and returning its result, but they have another return type. For **parameter types the same principle can be used for constructors** (i.e. it is also possible for [Constructor Methods](#constructor-methods-and-construction-process)) **or *static* methods, which also apply *@ImplAdaptionRule***.

Usually, the reason for adapting types by such rules is to reflect the limitation of the returned type in the derived class's method or the limitation of a parameter type when constructing an object of the derived class (see [Covariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science))).

The example below shows such use cases. The method *getSound* in class *Animal* returns the stored *sound* object. The architectural idea is that this object shall have different types based on the concrete animal class, e.g. it has type *SoundDog* for *AnimalDog* or *SoundLion* for *AnimalLion*. Therefore, the method *getSound* shall specify these concrete types in sub classes of *Animal*. This enables simpler code when getting more concrete objects, but would also require boilerplate code in each sub class.

This can be solved by applying the annotation ***@TypeAdaptionRule*** to method *getSound* in class *Animal*. Annotating the method itself means that the return type (and not any parameter type) shall be adapted in derived classes. Because of this annotation *getMethod* is generated automatically with adapted return types in the classes *SoundDog* and *SoundLion*. The generated methods just take the result of the original method and cast it to the adapted type. Of course, the architectural conditions mentioned above must be fulfilled in order to have such casts working for sure.

The name of the adapted return type is actually processed using the ***value*** in *@TypeAdaptionRule*. This value is an [Adaption Rule Specification](#adaption-rule-specification). Please note, that for *AnimalZebra* this rule would result in a type called *virtual.SoundZebra*. Because the generation process actually **searches this type, but cannot find it, the type remains unchanged**. Therefore, there is no need to generate *getMethod* in *AnimalZebra*.

The parameter in the constructor of class *Animal* is annotated by *@TypeAdaptionRule* as well. According to the principles above, the constructor is generated for child classes and the annotated parameter type is adapted. In this case it means that *AnimalDog* can only be constructed by passing a *SoundDog* object and *AnimalLion* by passing a *SoundLion* object. The passed objects are automatically passed to the parent class's constructor, of course.

Please note again, that there is a special behavior for constructors. Although there is no type *SoundZebra* for *AnimalZebra*, which means that there is no type change for the constructor in *AnimalZebra*, it is still generated in order to enable the construction of *AnimalZebra*. Hence, there is **no need for implementing the constructor in *AnimalZebra* manually**.

##### Input (Code)

[!include_code code_modification_type.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_Type_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_Type_Out.png)

##### Important

> The type resulting from the [Adaption Rule Specification](#adaption-rule-specification) should be fully qualified in order to avoid namespace problems.

##### Hint

> The described methodology does not only work within regular class hierarchies. Also classes extended by trait classes with (trait) methods using *@TypeAdaptionRule* will apply such rules and types will be adapted in further processing.

##### Limitation

> The adaption of type parameters within generic types is usually only possible, if using wildcards. For example, the return type *java.util.List<Sound>* cannot be adapted to *java.util.List<SoundDog>*, but *java.util.List<? extends Sound>* can be adapted to *java.util.List<? extends SoundDog>*.
>
> This must also be respected, if using collection types, *@TypeAdaptionRule* and the generation of accessors and mutators (see [Generate Accessors and Mutators](#generate-accessors-and-mutators)) together.

#### Reimplement Constructors without Parameters

The example in [Reimplement Constructors and Methods with Adapted Parameter and Return Types](#reimplement-constructors-and-methods-with-adapted-parameter-and-return-types) shows how constructors in derived classes, which basically have no functionality in addition, can be implemented automatically based on constructors in the parent class. This can be triggered by the type adaption rule on a parameter.

However, this use case can be valid even without adapting parameter types. For this, there is the annotation ***CopyConstructorRule***, which can be applied to several constructors in the base class. Each **annotated constructor will be implemented automatically in derived classes**, if there is no other manually implemented constructor.

An example can be found in the following section.

### Deactivate and Change Rules

Rules are usually applied for each derived class. However, there are several rules to avoid or change automatic class modification and even to stop for further derived classes.

In case of **methods, adaption is affected** (relating to further derivation) as soon as a derived class overrides it, i.e., there is a (manual) implementation of a method with the same name. In the class with the overridden method, there will be no adaption, of course. For further derived classes there are three possibilities:

1. Adaption will be **changed**, if the implemented method applies another adaption rule, i.e., the new adaption rule is applied.
2. Adaption will be **continued** unchanged, if the implemented method applies the annotation ***@AdaptedMethod***.
3. Adaption will be **stopped** in other cases.

In case of **constructors, adaption is affected** (relating to further derivation) as soon as a derived class implements any constructor. Any adaption rule for constructors is obsolete after that. However, it is possible to attach a new adaption rule to an implemented constructors again. This adaption rule will be considered for further derivation then.

The example below shows some of these cases. Method *getSound* in class *Animal* is annotated by *@TypeAdaptionRule*. It is already overridden in class *AnimalCarnivora*. However, it is annotated by *@AdaptedMethod* there, so adaption is not stopped and the method gets automatically generated in *AnimalFelidae*. The same method is overridden again in *AnimalLion*, but not annotated by *@AdaptedMethod* this time. Therefore, in the derived class *AnimalLionSouthAfrica* it is not generated.

Also the behavior for constructors is shown. Adaption is in place because *@TypeAdaptionRule* and *@CopyConstructorRule* (see [Reimplement Constructors without Parameters](#reimplement-constructors-without-parameters)) are applied to the two constructors in *Animal*, so both constructors are generated in *AnimalCarnivora* and *AnimalFelidae*. Later, in class *AnimalLion* there is one constructor implemented manually. Therefore, no constructor is generated in *AnimalLionSouthAfrica*, which is why a constructor must be implemented there by hand. 

##### Input (Code)

[!include_code code_modification_deactivate.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_Deactivate_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_Deactivate_Out.png)

### Generate Factory Methods

The ETAI library supports the **generation of factory methods**, i.e. methods for creating an object instead of using constructors. This feature enables [Constructor Methods](#constructor-methods-and-construction-process) in trait classes (see [Automatic Generation of Constructors](#automatic-generation-of-constructors)), and it can be useful, if additional code shall be executed automatically after object construction (see [Initialization after Object has been Constructed Completely](#initialization-after-object-has-been-constructed-completely)), or the factory methods become part of a factory (see [Generate Factories](#generate-factories)).

In order to generate factory methods, a class and derived classes must enable adaption (*@ApplyRules*). Afterwards, the first class in the type hierarchy, which shall get a factory method, must be annotated by a rule represented by ***@FactoryMethodRule***. All derived classes will also get a factory method according to the same rule. However, the rule can be changed by derived classes by annotating it again with other options. It can even be deactivated by annotating *@FactoryMethodRule* to a derived class and setting parameter *factoryMethod* to an empty string.

The annotation *@FactoryMethodRule* supports several parameters, which allow for different patterns, e.g. a naming pattern or if the method shall be generated inside a factory class (see [Generate Factories](#generate-factories)). The name of the generated factory method can be defined by parameter ***factoryMethod***. It supports a special character *%*, which is replaced by the name of the class, in which the factory method is generated.

The generated factory methods will reflect the parameters of the given constructors and factory methods will call them accordingly. This also works in scenarios, where this rule is combined with other rules and concepts of the ETAI library, i.e., it might be that constructors are not present in the Xtend code, because they will be generated as well (cp. [Reimplement Constructors without Parameters](#reimplement-constructors-without-parameters) or [Constructor Methods and Construction Process](#constructor-methods-and-construction-process)).

As soon as factory methods are generated, **constructors become *protected***, i.e., classes usually can only be created via factory method from outside.

#### Initialization after Object has been Constructed Completely

If there is code, which shall be **executed after the object has been constructed completely**, the parameter ***initMethod*** can help. With this parameter the name of a method can be specified. This method will be called automatically after the complete construction, no matter which factory method has been called. Thereby, the word "complete" is important, because this actually means that it is save to call any method, which is not possible within constructors (cp. [Calling Methods from a Constructor](https://www.javaspecialists.eu/archive/Issue210.html)). However, **the method must not have parameters or a return value (*void*)**.

In the example, class *Animal* specifies a factory method rule, which is why two factory methods are generated based on the two constructors of *Animal*. It also shows method *init*, which is called automatically after the object has been constructed via factory method. 

##### Input (Code)

[!include_code code_modification_factory_method.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_Factory_Method_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_Factory_Method_Out.png)

#### Factory Method  

The return type of the generated factory method usually matches the class it is generated for (see the example in [Initialization after Object has been Constructed Completely](#initialization-after-object-has-been-constructed-completely)).

However, it is possible to influence the return type of the generated methods. This can be accomplished via an adaption rule specification (see [Adaption Rule Specification](#adaption-rule-specification)) in parameter ***returnTypeAdaptionRule*** of *@FactoryMethodRule*. If the specified string is not empty, the rule will be applied in order to determine the return type of the factory method.

If the application of the adaption rule specification would lead to a string, which does not represent a locatable type, the generation does not consider the adaption rule.

### Generate Factories

Another parameter of *@FactoryMethodRule* (see [Generate Factory Methods](#generate-factory-methods)) is ***factoryInstance***. If it is non-empty, an inner class *Factory* (*private*) will be generated for all adapted classes. This class represents a **factory class** (see [Factory](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming))). In this case, the factory method will not be in the adapted class directly, but inside the factory class.

A *public*, *static* instance of this class will be made available via the adapted class as well. The name of this instance is given by *factoryInstance*. The variable will be declared *final* (or read-only) unless parameter ***factoryInstanceFinal*** of *@FactoryMethodRule* is explicitly set to *false*.

If generating factory classes, it can also be helpful to provide an interface for them, which allows for supporting the [Abstract Factory Pattern](https://en.wikipedia.org/wiki/Abstract_factory_pattern). The type of such an interface can be specified by setting the ***factoryInterface*** parameter.

An alternative to *factoryInterface* is ***factoryInterfaceVariable*** (both must not be used). In case of *factoryInterfaceVariable*, the name of the factory class's interface is not fixed, but will be equal to the value of an adaption variable (see [Use Adaption Variables](#use-adaption-variables)) in context of the adapted class. The name of the adaption variable is given by *factoryInterfaceVariable*. If the referred adaption variable is not set, an interface will not be applied.

By default, the generated factory classes will not use inheritance, i.e. the factory class generated for class *A* will not be the parent class (*extends*) for the factory class generated for class *B* which extends *A*. Inheritance can lead to the problem that the *B*-factory has to override the (factory) methods of the *A*-factory, which might be *abstract* methods, if *A* is *abstract*. This can result in errors, if *B* does not implement the same constructor as *A* (e.g. parameters changed). In this case, the factory method in the *B*-factory has other parameters compared to the factory method in the *A*-factory. However, if inheritance of generated factory classes is not an issue, this feature can be enabled by setting parameter ***factoryClassDerived*** of *@FactoryMethodRule* to *true*.

The example below shows the generation of factory classes. The rule specification can be found on *Animal*. Based on this, *AnimalLion* and *AnimalDog* generate two factory classes. Both implement their interface *IAnimalFactory*, and both can be referenced by a *static* attribute called *FACTORY*. Finally, method *main* shows how an *AnimalLion* object can be constructed.

##### Input (Code)

[!include_code code_modification_factory_class.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_Factory_Class_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_Factory_Class_Out.png)

### Generate Default Implementations of Missing Methods

The default implementation feature of the ETAI library can be used for **generating default implementations of methods automatically**. This is useful for simplifying the implementation of mock classes in testing scenarios, for example.

In order to use this feature, a non-abstract class is annotated by *@ImplementDefault*. Afterwards, **default methods** are generated in the Java code for all **missing methods**. Please note, that this feature is not based on rules and therefore does not require *@ApplyRules*.

The term "missing methods" refers to methods, which are declared *abstract* in a parent class (or in an implemented interface) and are not implemented, yet. The term "default method" means a method, which is empty and does not do anything in general. At least an appropriate value will be returned, if the method specifies a return type.

For all numerical return types the returned value is a representation of zero. For *boolean* the value *false* is returned. And finally for all non-primitive types, *null* is returned, e.g. for *String* or even *Integer*.  

The following example shows how to enable default implementation. The class *ElephantMock* does not implement any method. Because of the abstract method in the parent class *AnimalBase* and obligations due to the implemented interface *IElephant*, some methods like *getWeight* must be implemented. However, this is done automatically, so after applying ***@ImplementDefault*** there actually exists a (default) method *getWeight* which returns zero.

Please note, that generated default methods are annotated by ***@DefaultImplementation***, which might be available using reflection during runtime. 

##### Input (Code)

[!include_code code_implementation_simple.txt]

##### Input (Diagram)

![](images/PlantUML_ImplementDefault_Simple_In.png)

##### Output (Diagram)

![](images/PlantUML_ImplementDefault_Simple_Out.png)

### Adaption Rule Specification

Some features of the ETAI library require the specification of an *adaption rule* (cp. [Generate the Implementation of Constructors and Methods](#generate-the-implementation-of-constructors-and-methods) or [Reimplement Constructors and Methods with Adapted Parameter and Return Types](#reimplement-constructors-and-methods-with-adapted-parameter-and-return-types)).

An adaption rule specification is stored in a string, which contains **adaption function calls**. Thereby, each adaption function call looks similar to a regular Java function call. Multiple adaption function calls are separated by ";".

When applying an adaption rule the adaption function calls are executed sequentially and each function manipulates the **current value**, which is a string and starts *empty*. After the last adaption function call, this value represents also the *result*.

The following diagram describes this principle. The basis is this adaption rule specification:

| **apply(Test);append(MyWorld);replace(My,Hello)** |
|:-------------------------:|

![](images/PlantUML_AdaptionFunctions_Principle.png)

#### Adaption Functions

The following table lists supported *adaption functions*:

| Function                  | Description                                                    |
| ------------------------- |---------------------------------------------------------------:|
| ***apply(x)*** | *x* will replace the *current value* |
| ***append(x)*** | *x* will be appended to the *current value* |
| ***prepend(x)*** | *x* will be prepended to the *current value* |
| ***applyVariable(x)*** | adaption variable *x* (see [Use Adaption Variables](#use-adaption-variables)) will be queried and replace the *current value* |
| ***appendVariable(x)*** | adaption variable *x* (see [Use Adaption Variables](#use-adaption-variables)) will be queried and be appended to the *current value* |
| ***prependVariable(x)*** | adaption variable *x* (see [Use Adaption Variables](#use-adaption-variables)) will be queried and be prepended to the *current value* |
| ***replace(x,y)*** | in the *current value* all occurrences of *x* will be replaced by<nobr>&nbsp;<nobr>*y* |
| ***replaceAll(x,y)*** | in the *current value* all occurrences of *x* will be replaced by *y* (support of [regular expressions](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum)) |
| ***replaceFirst(x,y)*** | in the *current value* the first occurrence of *x* will be replaced by *y* (support of [regular expressions](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#sum)) |
| ***addTypeParam(x)*** | *specific for type adaption rules*: *x* is an adaption rule specification (nested rule), which will be evaluated and (if not empty) added as type parameter to the *current value* |
| ***addTypeParamWildcardExtends(x)*** | *specific for type adaption rules*: *x* is an adaption rule specification (nested rule), which will be evaluated and (if not empty) added as type parameter to the *current value* using the format "? extends *result-of-x*"  |
| ***addTypeParamWildcardSuper(x)*** | *specific for type adaption rules*: *x* is an adaption rule specification (nested rule), which will be evaluated and (if not empty) added as type parameter to the *current value* using the format "? super *result-of-x*"  |
| ***alternative(x)*** | see [Adaption Function: *alternative*](#adaption-function-alternative) |

#### Predefined Adaption Variables

Within adaption rule specifications it is possible to access the values of **adaption variables**. They can be set and changed freely in context of a class hierarchy (see [Use Adaption Variables](#use-adaption-variables)). However, there are also predefined variables, which are usually automatically set in relation to the current generation context. An example can be found here: [Reimplement Constructors and Methods with Adapted Parameter and Return Types](#reimplement-constructors-and-methods-with-adapted-parameter-and-return-types).

The following table shows existing predefined adaption variables:

| Adaption Variable         | Value                                                    |
| ------------------------- |---------------------------------------------------------------:|
| ***var.package*** | the package name |
| ***var.class.simple*** | the class name (unqualified) |
| ***var.class.qualified*** | the fully qualified class name |
| ***var.class.abstract*** | if the class is abstract "true", otherwise "false" |
| ***var.class.typeparameters*** | the name of all type parameter (comma-separated) |
| ***var.class.typeparameters.count*** | the number of type parameters |
| ***var.class.typeparameter.1*** | the name of type parameter *#1* (if available) |
| ***var.class.typeparameter.2*** | the name of type parameter *#2* (if available) |
| *...* | |
| ***var.class.typeparameter.x*** | the name of type parameter *#x* (if available) |
| ***const.bracket.round.open*** | round bracket, open, "("<br>(enables workaround to access this character in specific situations) |
| ***const.bracket.round.close*** | round bracket, closed, "("<br>(enables workaround to access this character in specific situations) |

#### Adaption Function: *alternative*

The adaption function *alternative* can only be applied for type adaption rules (see [Reimplement Constructors and Methods with Adapted Parameter and Return Types](#reimplement-constructors-and-methods-with-adapted-parameter-and-return-types)) and is special. It **must be the last call** within an adaption rule specification (except other *alternative* calls) and opens an **alternative result path**. In general, within *alternative(x)* another adaption rule specification can be nested.

If the evaluation of the adaption rule until an *alternative* call does not result in a string which represents a valid type, the adaption rule within *alternative* will be evaluated and used as result (if valid).

The following diagram exemplifies this adaption rule specification:

| **apply(X1);alternative(replace(1,2));alternative(replace(2,3))** |
|:-------------------------:|

![](images/PlantUML_AdaptionFunctions_Alternative.png)

##### Limitation

> The adaption function *alternative* is applicable only on top-level (no further nesting).

### Use Adaption Variables

Within adaption rule specifications it is possible to access so-called **adaption variables**, e.g. via function *appendVariable* (see [Adaption Functions](#adaption-functions)). There are predefined adaption variables (see [Predefined Adaption Variables](#predefined-adaption-variables)), but it also possible to define own adaption variables and set values.

In order to set an adaption variable, the annotation ***@SetAdaptionVariable*** must be applied to a class. The variables which are set this way will be available for rule specifications within the annotated class and any derived class. Of course, a derived class can also override the value of the adaption variable using *@SetAdaptionVariable* again.

The following example shows how to set and override the adaption variables *var.cat.female* and *var.cat.striped*. They are also used in an *@ImplAdaptionRule*.

##### Input (Code)

[!include_code code_modification_variables.txt]

##### Input (Diagram)

![](images/PlantUML_Modification_Variables_In.png)

##### Output (Diagram)

![](images/PlantUML_Modification_Variables_Out.png)